--- 
layout: post
title: "Client riche/Serveur l\xC3\xA9ger - L'architecture client serveur de demain"
published: true
meta: 
  _edit_last: "1"
tags: 
- AJAX
- "D\xC3\xA9faut"
- Dojo
- GWT
- SproutCore
- XBL
- XUL
type: post
status: publish
---
L'utilisation intensive du javascript afin d'ajouter des effets visuels où des communications asynchrones avec le serveur a grandement amélioré l'ergonomie de nos sites web; On passe progressivement des documents aux application. En revanche cela n'a aucunement changé l'architecture des sites ni notre manière de coder. Grossièrement le fonctionnement actuel de la plupart des applications web est le suivant : Pour traiter une requête on analyse le contexte (session, paramètres, etc), manipule des données métier, et générons du code HTML. En somme, les trois parties du modèle MVC sont exécutées côté serveur.

Jusqu'à présent, pour des raisons de simplicité, de navigateurs ne respectant pas les standards, et de performances des moteurs javascripts, nous (développeurs) avons été bridés et n'avons pas utilisé tout le potentiel des outils standardisés par le W3C. Mais les choses ont avancé très vite ces derniers temps. La compétition est lancée entre les navigateurs pour savoir lequel aura le moteur Javascript le plus rapide : <a hreflang="en" href="http://ejohn.org/blog/tracemonkey/">TraceMonkey</a> (Firefox), <a hreflang="en" href="http://webkit.org/blog/214/introducing-squirrelfish-extreme/">SquirrelFish Extreme</a> (Webkit), <a hreflang="en" href="http://code.google.com/p/v8/">v8</a> (Google Chrome) !

<q><a hreflang="fr" href="http://standblog.org/blog/post/2008/09/19/SquirrelFish-Extreme">Et pendant ce temps là, Microsoft apprend à faire ses lacets</a></q>

C'est le début d'un tournant dans le développement de véritables applications web. Mais pour cela, il faut optimiser l'architecture actuelle un peu vieillotte : allégeons les serveurs et dynamisons les clients !Passons d'une architecture "server-centric" à "client-centric".
<div class="post-content">
<h3>Remettons chaque chose à sa place !</h3>
<strong>Pour qu'une interface soit la plus dynamique possible, elle doit être manipulée au niveau des couches les plus proches de l'utilisateur : non pas coté serveur, mais dans le navigateur web</strong>. Partant de ce constat, le seul rôle du serveur doit être de s'occuper des fonctions métier (création/suppression/modification, sécurité...). Il est réduit à la fonction de service web de type <acronym>SOAP</acronym> ou <acronym>REST</acronym> retournant des données (presque) brutes au format XML ou JSON.

Dans cette architecture, le client <a hreflang="fr" href="http://www.youtube.com/watch?v=HoA6debXqOM">incombe</a> de responsabilités bien plus importantes qu'afficher du code HTML. <strong>Le <em>contrôleur</em> déménage chez le client</strong> afin de prendre en main au plus tôt les évènements utilisateur. Il traite ces interactions en mettant à jour (une petite) fraction de l'interface en faisant si nécessaire des appels au serveurs.

Voici un schéma résumant la situation :
<a href="http://wp.didry.info/wp-content/uploads/2010/03/client-server-20-architecture1.png"><img class="aligncenter size-full wp-image-187" title="client-server-20-architecture1" src="http://wp.didry.info/wp-content/uploads/2010/03/client-server-20-architecture1.png" alt="" width="450" height="398" /></a>
<a href="http://www.it-eye.nl/weblog/2008/09/24/what-is-client-server-20/">source</a>
<h3>Avantages</h3>
Cette séparation logique des différentes couches apporte de nombreux avantages :
<ul>
	<li>meilleure distinction des métiers intervenants dans le développement d'un logiciel.</li>
	<li>amélioration de la réactivité des interfaces.</li>
	<li>échanges réseaux réduits au minimum</li>
	<li>maintenabilité accrue; permettant d'alléger les charges coté serveur en cas de besoin :
<ul>
	<li>mise en cache simplifiée.</li>
	<li>séparation des contenus statiques très distincte (permettant facilement l'utilisation de <acronym title="Content delivery network">CDN</acronym>)</li>
	<li>possibilité d'exporter facilement certains services sur d'autres serveurs.</li>
	<li>possibilité de réécrire certaines parties du serveur dans un autre langage  sans avoir à modifier l'interface.</li>
</ul>
</li>
	<li>ouverture naturelle des données par le biais des services web fournis.
<ul>
	<li>création d'applications complémentaires par des développeur tiers.</li>
	<li>interfaçage avec d'autres applications.</li>
</ul>
</li>
	<li>développement d'applications "hors ligne" simplifié</li>
	<li>serveur stateless</li>
</ul>
<h3>Quels sont les outils à notre disposition ?</h3>
Les outils (libres et standart-based) à notre disposition sont peu nombreux. Présent nativement dans chaque navigateur, Javascript est donc le langage le plus à même de réaliser les tâches que nous avons décrites ci-dessus.

Les librairies javascript sont encore peu poussées et ne proposent que des briques de base pour la construction d'interfaces. Je trouve qu'elles occupent la même place que les paquets PEAR il y a quelques années, avant que n'apparaissent les frameworks web que nous connaissons aujourd'hui.

Ce dont nous avons besoin est donc un véritable framework de développement javascript. Je vais essayer de présenter certains de ces outils sans rentrer dans les détails car ils sont pour le moment nouveaux pour moi.
<h4><acronym title="Google Web Toolkit">GWT</acronym></h4>
<a href="http://wp.didry.info/wp-content/uploads/2010/03/gwt-logo.png"><img class="alignright size-full wp-image-190" title="gwt-logo" src="http://wp.didry.info/wp-content/uploads/2010/03/gwt-logo.png" alt="" width="100" height="100" /></a>

GWT propose aux développeurs de créer une application web en l'écrivant à la manière d'une IHM Java standard. Les outils fournis par Google se chargent ensuite de "traduire" le code Java en Javascript et HTML. Les principes sont exactement ceux évoqués plus haut : l'interface graphique en HTML est manipulée par du code javascript, et l'échange de données avec le serveur est réduit au minimum par le biais d'appels RPC.

GWT est pour moi l'outil le plus adapté pour écrire des application web dignes de ce nom. L'inconvénient le plus évoqué est sa courbe d'apprentissage assez raide...à vérifier dans un futur billet...

...L'ajout de Java sur la plateforme Google Apps Engine donnera peut être un coup de pouce à l'adoption de ce puissant outil !

Vous trouverez un guide de démarrage avec GWT ici <a title="http://www.vogella.de/articles/GWT/article.html" href="http://www.vogella.de/articles/GWT/article.html">http://www.vogella.de/articles/GWT/...</a>
<a title="http://www.slideshare.net/dgirard/gwt-gears-the-browser-is-the-platform/v1" href="http://www.slideshare.net/dgirard/gwt-gears-the-browser-is-the-platform/v1">http://www.slideshare.net/dgirard/g...</a>
<a title="http://en.wikipedia.org/wiki/Google_Web_Toolkit" href="http://en.wikipedia.org/wiki/Google_Web_Toolkit">http://en.wikipedia.org/wiki/Google...</a>
<a title="http://code.google.com/webtoolkit/" href="http://code.google.com/webtoolkit/">http://code.google.com/webtoolkit/</a>
<h4>Sproutcore</h4>
<a href="http://wp.didry.info/wp-content/uploads/2010/03/logo.png"><img class="alignright size-full wp-image-192" title="logo" src="http://wp.didry.info/wp-content/uploads/2010/03/logo.png" alt="" width="277" height="62" /></a>

Sous Sproutcore le développeur doit écrire chaque entité du modèle MVC en Javascript. Tout comme plusieurs framework (php|ruby|python), Sproutcore propose de générer des squelettes de classe pour vos modèles et contrôleurs. Les vues sont quant à elles écrites avec le moteur de template  eRuby puis traduites en HTML.

C'est encore une fois un démarche très déroutante, mais c'est pourtant le framework choisi par Apple pour son application <em>Mobile.me</em>.

À première vue, l'inconvénient est qu'il faut à la fois décrire son modèle de données dans des classes Javascript et dans ses services Web; il manque un couche permettant de faire automatiquement le lien entre les deux.

<a title="http://www.sproutcore.com/about/" href="http://www.sproutcore.com/about/">http://www.sproutcore.com/about/</a>
<h4>Dojo</h4>
<a href="http://wp.didry.info/wp-content/uploads/2010/03/sellit.png"><img class="alignright size-thumbnail wp-image-194" title="sellit" src="http://wp.didry.info/wp-content/uploads/2010/03/sellit-150x70.png" alt="" width="150" height="70" /></a>

Dojo propose un tas de widgets pouvant s'interfacer avec des services web et également un système de template
<a href="http://unclescript.blogspot.com/2008/10/tech-talk-on-thin-server-architecture.html">Cette présentation</a> introduit aussi un système intéressant de datastore coté client, de description de service (une sorte de WSDL en JSON), et d'échange de schémas au format JSON.

<a title="http://dojotoolkit.org/" href="http://dojotoolkit.org/">http://dojotoolkit.org/</a>
<h4>Et les autres ?</h4>
D'autres existent bien sûr, mais je n'ai pas le temps de m'y coller
<ul>
	<li><a href="http://echo.nextapp.com/site/echo3">Echo3</a></li>
	<li><a href="http://www.itmill.com/itmill-toolkit/">IT Mill</a></li>
	<li><a href="http://extjs.com/">ExtJS</a></li>
	<li><a href="http://www.openlaszlo.org/">OpenLaszlo</a></li>
</ul>
Je n'ai pas parlé des outils de microsoft ou adobe qui restent fermé ou partiellement ouvert. <a href="http://ajaxian.com/archives/how-flash-can-join-the-open-web">Adobe y gagnerait pourtant à plus ouvrir Flex...</a>,
<h3>Il faut continuer à chercher...</h3>
Malgré ces belles technologies, certains problèmes ne sont pas résolus, et ne le seront peut être jamais puisque l'architecture des sites web est complètement différente :
<ul>
	<li>Indexation &gt; web sémentique</li>
	<li>Accessibilité (GoogleHealth qui fonctionne avec GWT aurait résolu ces problèmes)</li>
	<li>Sécurité des services RESTful &amp; attaques par CSRF</li>
	<li>HTML a été créé pour décrire des documents, et non pas des applications. Les outils proposés par Mozilla (<a hreflang="fr" href="http://fr.wikipedia.org/wiki/XUL">XUL</a> &amp; <a hreflang="fr" href="http://fr.wikipedia.org/wiki/XBL">XBL</a>) seraient en revanche plus adaptés... Je ne sais par contre pas s'ils ont été standardisés.</li>
</ul>
</div>
